// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"vine-template-rpc/internal/emonitor/data/ent/equipment"
	"vine-template-rpc/internal/emonitor/data/ent/predicate"
	"vine-template-rpc/internal/emonitor/data/ent/site"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCar       = "Car"
	TypeCustomer  = "Customer"
	TypeEquipment = "Equipment"
	TypeSite      = "Site"
)

// CarMutation represents an operation that mutates the Car nodes in the graph.
type CarMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Car, error)
	predicates    []predicate.Car
}

var _ ent.Mutation = (*CarMutation)(nil)

// carOption allows management of the mutation configuration using functional options.
type carOption func(*CarMutation)

// newCarMutation creates new mutation for the Car entity.
func newCarMutation(c config, op Op, opts ...carOption) *CarMutation {
	m := &CarMutation{
		config:        c,
		op:            op,
		typ:           TypeCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarID sets the ID field of the mutation.
func withCarID(id int) carOption {
	return func(m *CarMutation) {
		var (
			err   error
			once  sync.Once
			value *Car
		)
		m.oldValue = func(ctx context.Context) (*Car, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Car.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCar sets the old Car of the mutation.
func withCar(node *Car) carOption {
	return func(m *CarMutation) {
		m.oldValue = func(context.Context) (*Car, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Car.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CarMutation builder.
func (m *CarMutation) Where(ps ...predicate.Car) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Car, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Car).
func (m *CarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Car field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Car numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Car nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Car unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Car edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Customer, error)
	predicates    []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Customer edge %s", name)
}

// EquipmentMutation represents an operation that mutates the Equipment nodes in the graph.
type EquipmentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	_type         *string
	status        *string
	remark        *string
	lon           *string
	lat           *string
	address       *string
	install_time  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Equipment, error)
	predicates    []predicate.Equipment
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows management of the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for the Equipment entity.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the ID field of the mutation.
func withEquipmentID(id uuid.UUID) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Equipment entities.
func (m *EquipmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Equipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EquipmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EquipmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EquipmentMutation) ClearName() {
	m.name = nil
	m.clearedFields[equipment.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EquipmentMutation) NameCleared() bool {
	_, ok := m.clearedFields[equipment.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EquipmentMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, equipment.FieldName)
}

// SetType sets the "type" field.
func (m *EquipmentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EquipmentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *EquipmentMutation) ClearType() {
	m._type = nil
	m.clearedFields[equipment.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *EquipmentMutation) TypeCleared() bool {
	_, ok := m.clearedFields[equipment.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *EquipmentMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, equipment.FieldType)
}

// SetStatus sets the "status" field.
func (m *EquipmentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EquipmentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EquipmentMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[equipment.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EquipmentMutation) StatusCleared() bool {
	_, ok := m.clearedFields[equipment.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EquipmentMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, equipment.FieldStatus)
}

// SetRemark sets the "remark" field.
func (m *EquipmentMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EquipmentMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EquipmentMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[equipment.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EquipmentMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[equipment.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EquipmentMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, equipment.FieldRemark)
}

// SetLon sets the "lon" field.
func (m *EquipmentMutation) SetLon(s string) {
	m.lon = &s
}

// Lon returns the value of the "lon" field in the mutation.
func (m *EquipmentMutation) Lon() (r string, exists bool) {
	v := m.lon
	if v == nil {
		return
	}
	return *v, true
}

// OldLon returns the old "lon" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldLon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLon: %w", err)
	}
	return oldValue.Lon, nil
}

// ClearLon clears the value of the "lon" field.
func (m *EquipmentMutation) ClearLon() {
	m.lon = nil
	m.clearedFields[equipment.FieldLon] = struct{}{}
}

// LonCleared returns if the "lon" field was cleared in this mutation.
func (m *EquipmentMutation) LonCleared() bool {
	_, ok := m.clearedFields[equipment.FieldLon]
	return ok
}

// ResetLon resets all changes to the "lon" field.
func (m *EquipmentMutation) ResetLon() {
	m.lon = nil
	delete(m.clearedFields, equipment.FieldLon)
}

// SetLat sets the "lat" field.
func (m *EquipmentMutation) SetLat(s string) {
	m.lat = &s
}

// Lat returns the value of the "lat" field in the mutation.
func (m *EquipmentMutation) Lat() (r string, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldLat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// ClearLat clears the value of the "lat" field.
func (m *EquipmentMutation) ClearLat() {
	m.lat = nil
	m.clearedFields[equipment.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *EquipmentMutation) LatCleared() bool {
	_, ok := m.clearedFields[equipment.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *EquipmentMutation) ResetLat() {
	m.lat = nil
	delete(m.clearedFields, equipment.FieldLat)
}

// SetAddress sets the "address" field.
func (m *EquipmentMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EquipmentMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *EquipmentMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[equipment.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *EquipmentMutation) AddressCleared() bool {
	_, ok := m.clearedFields[equipment.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *EquipmentMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, equipment.FieldAddress)
}

// SetInstallTime sets the "install_time" field.
func (m *EquipmentMutation) SetInstallTime(s string) {
	m.install_time = &s
}

// InstallTime returns the value of the "install_time" field in the mutation.
func (m *EquipmentMutation) InstallTime() (r string, exists bool) {
	v := m.install_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallTime returns the old "install_time" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldInstallTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallTime: %w", err)
	}
	return oldValue.InstallTime, nil
}

// ClearInstallTime clears the value of the "install_time" field.
func (m *EquipmentMutation) ClearInstallTime() {
	m.install_time = nil
	m.clearedFields[equipment.FieldInstallTime] = struct{}{}
}

// InstallTimeCleared returns if the "install_time" field was cleared in this mutation.
func (m *EquipmentMutation) InstallTimeCleared() bool {
	_, ok := m.clearedFields[equipment.FieldInstallTime]
	return ok
}

// ResetInstallTime resets all changes to the "install_time" field.
func (m *EquipmentMutation) ResetInstallTime() {
	m.install_time = nil
	delete(m.clearedFields, equipment.FieldInstallTime)
}

// Where appends a list predicates to the EquipmentMutation builder.
func (m *EquipmentMutation) Where(ps ...predicate.Equipment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Equipment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, equipment.FieldName)
	}
	if m._type != nil {
		fields = append(fields, equipment.FieldType)
	}
	if m.status != nil {
		fields = append(fields, equipment.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, equipment.FieldRemark)
	}
	if m.lon != nil {
		fields = append(fields, equipment.FieldLon)
	}
	if m.lat != nil {
		fields = append(fields, equipment.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, equipment.FieldAddress)
	}
	if m.install_time != nil {
		fields = append(fields, equipment.FieldInstallTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldName:
		return m.Name()
	case equipment.FieldType:
		return m.GetType()
	case equipment.FieldStatus:
		return m.Status()
	case equipment.FieldRemark:
		return m.Remark()
	case equipment.FieldLon:
		return m.Lon()
	case equipment.FieldLat:
		return m.Lat()
	case equipment.FieldAddress:
		return m.Address()
	case equipment.FieldInstallTime:
		return m.InstallTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldName:
		return m.OldName(ctx)
	case equipment.FieldType:
		return m.OldType(ctx)
	case equipment.FieldStatus:
		return m.OldStatus(ctx)
	case equipment.FieldRemark:
		return m.OldRemark(ctx)
	case equipment.FieldLon:
		return m.OldLon(ctx)
	case equipment.FieldLat:
		return m.OldLat(ctx)
	case equipment.FieldAddress:
		return m.OldAddress(ctx)
	case equipment.FieldInstallTime:
		return m.OldInstallTime(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipment.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case equipment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case equipment.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case equipment.FieldLon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLon(v)
		return nil
	case equipment.FieldLat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case equipment.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case equipment.FieldInstallTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallTime(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipment.FieldName) {
		fields = append(fields, equipment.FieldName)
	}
	if m.FieldCleared(equipment.FieldType) {
		fields = append(fields, equipment.FieldType)
	}
	if m.FieldCleared(equipment.FieldStatus) {
		fields = append(fields, equipment.FieldStatus)
	}
	if m.FieldCleared(equipment.FieldRemark) {
		fields = append(fields, equipment.FieldRemark)
	}
	if m.FieldCleared(equipment.FieldLon) {
		fields = append(fields, equipment.FieldLon)
	}
	if m.FieldCleared(equipment.FieldLat) {
		fields = append(fields, equipment.FieldLat)
	}
	if m.FieldCleared(equipment.FieldAddress) {
		fields = append(fields, equipment.FieldAddress)
	}
	if m.FieldCleared(equipment.FieldInstallTime) {
		fields = append(fields, equipment.FieldInstallTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	switch name {
	case equipment.FieldName:
		m.ClearName()
		return nil
	case equipment.FieldType:
		m.ClearType()
		return nil
	case equipment.FieldStatus:
		m.ClearStatus()
		return nil
	case equipment.FieldRemark:
		m.ClearRemark()
		return nil
	case equipment.FieldLon:
		m.ClearLon()
		return nil
	case equipment.FieldLat:
		m.ClearLat()
		return nil
	case equipment.FieldAddress:
		m.ClearAddress()
		return nil
	case equipment.FieldInstallTime:
		m.ClearInstallTime()
		return nil
	}
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldName:
		m.ResetName()
		return nil
	case equipment.FieldType:
		m.ResetType()
		return nil
	case equipment.FieldStatus:
		m.ResetStatus()
		return nil
	case equipment.FieldRemark:
		m.ResetRemark()
		return nil
	case equipment.FieldLon:
		m.ResetLon()
		return nil
	case equipment.FieldLat:
		m.ResetLat()
		return nil
	case equipment.FieldAddress:
		m.ResetAddress()
		return nil
	case equipment.FieldInstallTime:
		m.ResetInstallTime()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// SiteMutation represents an operation that mutates the Site nodes in the graph.
type SiteMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	_type             *string
	dept              *string
	owner             *string
	remark            *string
	lon               *string
	lat               *string
	status            *int
	addstatus         *int
	address           *string
	last_service_time *string
	create_time       *string
	creator           *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Site, error)
	predicates        []predicate.Site
}

var _ ent.Mutation = (*SiteMutation)(nil)

// siteOption allows management of the mutation configuration using functional options.
type siteOption func(*SiteMutation)

// newSiteMutation creates new mutation for the Site entity.
func newSiteMutation(c config, op Op, opts ...siteOption) *SiteMutation {
	m := &SiteMutation{
		config:        c,
		op:            op,
		typ:           TypeSite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSiteID sets the ID field of the mutation.
func withSiteID(id uuid.UUID) siteOption {
	return func(m *SiteMutation) {
		var (
			err   error
			once  sync.Once
			value *Site
		)
		m.oldValue = func(ctx context.Context) (*Site, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Site.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSite sets the old Site of the mutation.
func withSite(node *Site) siteOption {
	return func(m *SiteMutation) {
		m.oldValue = func(context.Context) (*Site, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Site entities.
func (m *SiteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SiteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SiteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Site.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SiteMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SiteMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SiteMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *SiteMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SiteMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *SiteMutation) ClearType() {
	m._type = nil
	m.clearedFields[site.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *SiteMutation) TypeCleared() bool {
	_, ok := m.clearedFields[site.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *SiteMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, site.FieldType)
}

// SetDept sets the "dept" field.
func (m *SiteMutation) SetDept(s string) {
	m.dept = &s
}

// Dept returns the value of the "dept" field in the mutation.
func (m *SiteMutation) Dept() (r string, exists bool) {
	v := m.dept
	if v == nil {
		return
	}
	return *v, true
}

// OldDept returns the old "dept" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldDept(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDept is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDept requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDept: %w", err)
	}
	return oldValue.Dept, nil
}

// ClearDept clears the value of the "dept" field.
func (m *SiteMutation) ClearDept() {
	m.dept = nil
	m.clearedFields[site.FieldDept] = struct{}{}
}

// DeptCleared returns if the "dept" field was cleared in this mutation.
func (m *SiteMutation) DeptCleared() bool {
	_, ok := m.clearedFields[site.FieldDept]
	return ok
}

// ResetDept resets all changes to the "dept" field.
func (m *SiteMutation) ResetDept() {
	m.dept = nil
	delete(m.clearedFields, site.FieldDept)
}

// SetOwner sets the "owner" field.
func (m *SiteMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *SiteMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ClearOwner clears the value of the "owner" field.
func (m *SiteMutation) ClearOwner() {
	m.owner = nil
	m.clearedFields[site.FieldOwner] = struct{}{}
}

// OwnerCleared returns if the "owner" field was cleared in this mutation.
func (m *SiteMutation) OwnerCleared() bool {
	_, ok := m.clearedFields[site.FieldOwner]
	return ok
}

// ResetOwner resets all changes to the "owner" field.
func (m *SiteMutation) ResetOwner() {
	m.owner = nil
	delete(m.clearedFields, site.FieldOwner)
}

// SetRemark sets the "remark" field.
func (m *SiteMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SiteMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SiteMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[site.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SiteMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[site.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SiteMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, site.FieldRemark)
}

// SetLon sets the "lon" field.
func (m *SiteMutation) SetLon(s string) {
	m.lon = &s
}

// Lon returns the value of the "lon" field in the mutation.
func (m *SiteMutation) Lon() (r string, exists bool) {
	v := m.lon
	if v == nil {
		return
	}
	return *v, true
}

// OldLon returns the old "lon" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldLon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLon: %w", err)
	}
	return oldValue.Lon, nil
}

// ClearLon clears the value of the "lon" field.
func (m *SiteMutation) ClearLon() {
	m.lon = nil
	m.clearedFields[site.FieldLon] = struct{}{}
}

// LonCleared returns if the "lon" field was cleared in this mutation.
func (m *SiteMutation) LonCleared() bool {
	_, ok := m.clearedFields[site.FieldLon]
	return ok
}

// ResetLon resets all changes to the "lon" field.
func (m *SiteMutation) ResetLon() {
	m.lon = nil
	delete(m.clearedFields, site.FieldLon)
}

// SetLat sets the "lat" field.
func (m *SiteMutation) SetLat(s string) {
	m.lat = &s
}

// Lat returns the value of the "lat" field in the mutation.
func (m *SiteMutation) Lat() (r string, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldLat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// ClearLat clears the value of the "lat" field.
func (m *SiteMutation) ClearLat() {
	m.lat = nil
	m.clearedFields[site.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *SiteMutation) LatCleared() bool {
	_, ok := m.clearedFields[site.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *SiteMutation) ResetLat() {
	m.lat = nil
	delete(m.clearedFields, site.FieldLat)
}

// SetStatus sets the "status" field.
func (m *SiteMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SiteMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SiteMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SiteMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SiteMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAddress sets the "address" field.
func (m *SiteMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SiteMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *SiteMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[site.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *SiteMutation) AddressCleared() bool {
	_, ok := m.clearedFields[site.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *SiteMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, site.FieldAddress)
}

// SetLastServiceTime sets the "last_service_time" field.
func (m *SiteMutation) SetLastServiceTime(s string) {
	m.last_service_time = &s
}

// LastServiceTime returns the value of the "last_service_time" field in the mutation.
func (m *SiteMutation) LastServiceTime() (r string, exists bool) {
	v := m.last_service_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastServiceTime returns the old "last_service_time" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldLastServiceTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastServiceTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastServiceTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastServiceTime: %w", err)
	}
	return oldValue.LastServiceTime, nil
}

// ClearLastServiceTime clears the value of the "last_service_time" field.
func (m *SiteMutation) ClearLastServiceTime() {
	m.last_service_time = nil
	m.clearedFields[site.FieldLastServiceTime] = struct{}{}
}

// LastServiceTimeCleared returns if the "last_service_time" field was cleared in this mutation.
func (m *SiteMutation) LastServiceTimeCleared() bool {
	_, ok := m.clearedFields[site.FieldLastServiceTime]
	return ok
}

// ResetLastServiceTime resets all changes to the "last_service_time" field.
func (m *SiteMutation) ResetLastServiceTime() {
	m.last_service_time = nil
	delete(m.clearedFields, site.FieldLastServiceTime)
}

// SetCreateTime sets the "create_time" field.
func (m *SiteMutation) SetCreateTime(s string) {
	m.create_time = &s
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SiteMutation) CreateTime() (r string, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldCreateTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *SiteMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[site.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *SiteMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[site.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SiteMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, site.FieldCreateTime)
}

// SetCreator sets the "creator" field.
func (m *SiteMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SiteMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SiteMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[site.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SiteMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[site.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SiteMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, site.FieldCreator)
}

// Where appends a list predicates to the SiteMutation builder.
func (m *SiteMutation) Where(ps ...predicate.Site) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Site, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Site).
func (m *SiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SiteMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, site.FieldName)
	}
	if m._type != nil {
		fields = append(fields, site.FieldType)
	}
	if m.dept != nil {
		fields = append(fields, site.FieldDept)
	}
	if m.owner != nil {
		fields = append(fields, site.FieldOwner)
	}
	if m.remark != nil {
		fields = append(fields, site.FieldRemark)
	}
	if m.lon != nil {
		fields = append(fields, site.FieldLon)
	}
	if m.lat != nil {
		fields = append(fields, site.FieldLat)
	}
	if m.status != nil {
		fields = append(fields, site.FieldStatus)
	}
	if m.address != nil {
		fields = append(fields, site.FieldAddress)
	}
	if m.last_service_time != nil {
		fields = append(fields, site.FieldLastServiceTime)
	}
	if m.create_time != nil {
		fields = append(fields, site.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, site.FieldCreator)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case site.FieldName:
		return m.Name()
	case site.FieldType:
		return m.GetType()
	case site.FieldDept:
		return m.Dept()
	case site.FieldOwner:
		return m.Owner()
	case site.FieldRemark:
		return m.Remark()
	case site.FieldLon:
		return m.Lon()
	case site.FieldLat:
		return m.Lat()
	case site.FieldStatus:
		return m.Status()
	case site.FieldAddress:
		return m.Address()
	case site.FieldLastServiceTime:
		return m.LastServiceTime()
	case site.FieldCreateTime:
		return m.CreateTime()
	case site.FieldCreator:
		return m.Creator()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case site.FieldName:
		return m.OldName(ctx)
	case site.FieldType:
		return m.OldType(ctx)
	case site.FieldDept:
		return m.OldDept(ctx)
	case site.FieldOwner:
		return m.OldOwner(ctx)
	case site.FieldRemark:
		return m.OldRemark(ctx)
	case site.FieldLon:
		return m.OldLon(ctx)
	case site.FieldLat:
		return m.OldLat(ctx)
	case site.FieldStatus:
		return m.OldStatus(ctx)
	case site.FieldAddress:
		return m.OldAddress(ctx)
	case site.FieldLastServiceTime:
		return m.OldLastServiceTime(ctx)
	case site.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case site.FieldCreator:
		return m.OldCreator(ctx)
	}
	return nil, fmt.Errorf("unknown Site field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case site.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case site.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case site.FieldDept:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDept(v)
		return nil
	case site.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case site.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case site.FieldLon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLon(v)
		return nil
	case site.FieldLat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case site.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case site.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case site.FieldLastServiceTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastServiceTime(v)
		return nil
	case site.FieldCreateTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case site.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	}
	return fmt.Errorf("unknown Site field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SiteMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, site.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SiteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case site.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case site.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Site numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SiteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(site.FieldType) {
		fields = append(fields, site.FieldType)
	}
	if m.FieldCleared(site.FieldDept) {
		fields = append(fields, site.FieldDept)
	}
	if m.FieldCleared(site.FieldOwner) {
		fields = append(fields, site.FieldOwner)
	}
	if m.FieldCleared(site.FieldRemark) {
		fields = append(fields, site.FieldRemark)
	}
	if m.FieldCleared(site.FieldLon) {
		fields = append(fields, site.FieldLon)
	}
	if m.FieldCleared(site.FieldLat) {
		fields = append(fields, site.FieldLat)
	}
	if m.FieldCleared(site.FieldAddress) {
		fields = append(fields, site.FieldAddress)
	}
	if m.FieldCleared(site.FieldLastServiceTime) {
		fields = append(fields, site.FieldLastServiceTime)
	}
	if m.FieldCleared(site.FieldCreateTime) {
		fields = append(fields, site.FieldCreateTime)
	}
	if m.FieldCleared(site.FieldCreator) {
		fields = append(fields, site.FieldCreator)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SiteMutation) ClearField(name string) error {
	switch name {
	case site.FieldType:
		m.ClearType()
		return nil
	case site.FieldDept:
		m.ClearDept()
		return nil
	case site.FieldOwner:
		m.ClearOwner()
		return nil
	case site.FieldRemark:
		m.ClearRemark()
		return nil
	case site.FieldLon:
		m.ClearLon()
		return nil
	case site.FieldLat:
		m.ClearLat()
		return nil
	case site.FieldAddress:
		m.ClearAddress()
		return nil
	case site.FieldLastServiceTime:
		m.ClearLastServiceTime()
		return nil
	case site.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case site.FieldCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Site nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SiteMutation) ResetField(name string) error {
	switch name {
	case site.FieldName:
		m.ResetName()
		return nil
	case site.FieldType:
		m.ResetType()
		return nil
	case site.FieldDept:
		m.ResetDept()
		return nil
	case site.FieldOwner:
		m.ResetOwner()
		return nil
	case site.FieldRemark:
		m.ResetRemark()
		return nil
	case site.FieldLon:
		m.ResetLon()
		return nil
	case site.FieldLat:
		m.ResetLat()
		return nil
	case site.FieldStatus:
		m.ResetStatus()
		return nil
	case site.FieldAddress:
		m.ResetAddress()
		return nil
	case site.FieldLastServiceTime:
		m.ResetLastServiceTime()
		return nil
	case site.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case site.FieldCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown Site field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SiteMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SiteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SiteMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SiteMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Site unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SiteMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Site edge %s", name)
}
